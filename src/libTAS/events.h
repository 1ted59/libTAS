/*
    Copyright 2015-2016 Cl√©ment Gallet <clement.gallet@ens-lyon.org>

    This file is part of libTAS.

    libTAS is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    libTAS is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with libTAS.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef EVENTS_H_INCLUDED
#define EVENTS_H_INCLUDED

#include "global.h"
#include "../external/SDL.h"

/**
 *  Checks the event queue for messages and optionally returns them.
 *
 *  If \c action is ::SDL_ADDEVENT, up to \c numevents events will be added to
 *  the back of the event queue.
 *
 *  If \c action is ::SDL_PEEKEVENT, up to \c numevents events at the front
 *  of the event queue, within the specified minimum and maximum type,
 *  will be returned and will not be removed from the queue.
 *
 *  If \c action is ::SDL_GETEVENT, up to \c numevents events at the front
 *  of the event queue, within the specified minimum and maximum type,
 *  will be returned and will be removed from the queue.
 *
 *  \return The number of events actually stored, or -1 if there was an error.
 *
 *  This function is thread-safe.
 */
OVERRIDE int SDL_PeepEvents(SDL_Event* events, int numevents, SDL_eventaction action, ...);

/**
 *  Checks to see if certain event types are in the event queue.
 */
OVERRIDE SDL_bool SDL_HasEvent(Uint32 type);
OVERRIDE SDL_bool SDL_HasEvents(Uint32 minType, Uint32 maxType);

/**
 *  This function clears events from the event queue
 *  This function only affects currently queued events. If you want to make
 *  sure that all pending OS events are flushed, you can call SDL_PumpEvents()
 *  on the main thread immediately before the flush call.
 */
OVERRIDE void SDL_FlushEvent(Uint32 type);
OVERRIDE void SDL_FlushEvents(Uint32 minType, Uint32 maxType);

/**
 *  \brief Polls for currently pending events.
 *
 *  \return 1 if there are any pending events, or 0 if there are none available.
 *
 *  \param event If not NULL, the next event is removed from the queue and
 *               stored in that area.
 */
OVERRIDE int SDL_PollEvent(SDL_Event* event);

/**
 *  \brief Waits indefinitely for the next available event.
 *
 *  \return 1, or 0 if there was an error while waiting for events.
 *
 *  \param event If not NULL, the next event is removed from the queue and
 *               stored in that area.
 */
OVERRIDE int SDL_WaitEvent(SDL_Event * event);

/**
 *  \brief Waits until the specified timeout (in milliseconds) for the next
 *         available event.
 *
 *  \return 1, or 0 if there was an error while waiting for events.
 *
 *  \param event If not NULL, the next event is removed from the queue and
 *               stored in that area.
 *  \param timeout The timeout (in milliseconds) to wait for next event.
 */
OVERRIDE int SDL_WaitEventTimeout(SDL_Event * event, int timeout);

typedef int (* SDL_EventFilter) (void *userdata, SDL_Event * event);

/**
 *  Sets up a filter to process all events before they change internal state and
 *  are posted to the internal event queue.
 *
 *  The filter is prototyped as:
 *  \code
 *      int SDL_EventFilter(void *userdata, SDL_Event * event);
 *  \endcode
 *
 *  If the filter returns 1, then the event will be added to the internal queue.
 *  If it returns 0, then the event will be dropped from the queue, but the
 *  internal state will still be updated.  This allows selective filtering of
 *  dynamically arriving events.
 *
 *  \warning  Be very careful of what you do in the event filter function, as
 *            it may run in a different thread!
 *
 *  There is one caveat when dealing with the ::SDL_QuitEvent event type.  The
 *  event filter is only called when the window manager desires to close the
 *  application window.  If the event filter returns 1, then the window will
 *  be closed, otherwise the window will remain open if possible.
 *
 *  If the quit event is generated by an interrupt signal, it will bypass the
 *  internal queue and be delivered to the application at the next event poll.
 */
OVERRIDE void SDL_SetEventFilter(SDL_EventFilter filter, void *userdata);

/**
 *  Return the current event filter - can be used to "chain" filters.
 *  If there is no event filter set, this function returns SDL_FALSE.
 */
OVERRIDE SDL_bool SDL_GetEventFilter(SDL_EventFilter * filter, void **userdata);

/**
 *  Add a function which is called when an event is added to the queue.
 */
OVERRIDE void SDL_AddEventWatch(SDL_EventFilter filter, void *userdata);

/**
 *  Remove an event watch function added with SDL_AddEventWatch()
 */
OVERRIDE void SDL_DelEventWatch(SDL_EventFilter filter, void *userdata);

/**
 *  Run the filter function on the current event queue, removing any
 *  events for which the filter returns 0.
 */
OVERRIDE void SDL_FilterEvents(SDL_EventFilter filter, void *userdata);

/* 
 * This helper function will return a number of events from the generated event queue.
 * This event queue consists on the real SDL event queue with our own filter
 * (e.g. removing real input events)
 * and generated SDL events containing mostly inputs passed from linTAS.
 *
 * Because SDL has multiple ways of accessing the event queue, we made this function
 * with two parameter indicating the number of events we want and if we need 
 * to update the queue by removing the returned event, or keep it in the queue.
 * 
 * The function returns the number of events returned.
 */
int getSDL2Events(SDL_Event *events, int numevents, int update, Uint32 minType, Uint32 maxType);

/* 
 * Same as the getSDL2Events, except that we are dealing with SDL 1.2 events.
 * These events have a different structure, and the filtering is also different.
 * Otherwise, the function acheive the same goal.
 */
int getSDL1Events(SDL1::SDL_Event *events, int numevents, int update, Uint32 mask);

/* Return if the SDL event must be passed to the game or be filtered */
int filterSDL1Event(SDL1::SDL_Event *event);

/* Return if the SDL event must be passed to the game or be filtered */
int filterSDL2Event(SDL_Event *event);

/* Print which event type is it */
void logEvent(SDL_Event *event);

/* Link function pointers to real SDL functions */
void link_sdlevents(void);

#endif

